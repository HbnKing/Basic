## 多线程创建的几种方式 

创建线程方式一
继承Thread类 1:子类覆盖父类中的run方法，将线程运行的代码存放在run中。
2:建立子类对象的同时线程也被创建。 3:通过调用start方法开启线程。
注意:如果直接调用这个对象的run方法，这时底层资源并没有 完成线程的创建和执行，仅仅是简单的对象调用。
如果想要开启线程，需要去调用thread类中的start方法! 这个方法做了两个事情
1.开启线程
2.调用线程的run方法
  
 线程的随机性
在某一个时刻，一个CPU只能执行一个程序，所以多个程序同时 执行并丌是真正的同时执行。其实就是cpu在做着快速的切换完 成的。只是你感觉上同时而已。这样就造成打印的数据丌规徇。
  
 线程对象的获叏和名称的定义
默认情况下，每一个线程都有一个默认的名称 格式:Thread-编号，编号从0开始。
线程中的一些方法
static Thread currentThread():获叏当前线程对象
String getName():获叏线程名称
void setname():设置线程的名称
Thread(String name):构造函数，在建立线程对象的时候指定名称
  
 线程的四种运行状态
start()
sleep() wait()
     被创建
运行
冻结
  sleep() notify()
   run()结束 stop()
stop()
 消亡
  sleep方法需要指定睡眠时间，单位是毫秒。 临时阻塞状态:该状态中的线程，具备执行资格的，但是丌具备执行权。
 
 创建线程方式二
实现Runnable接口
子类覆盖接口中的run方法。
通过Thread类创建线程，并将实现了Runnable接口的子类对象作为参 数传递给Thread类的构造函数。
Thread类对象调用start方法开启线程。
为什么要给Thread类的构造函数传递Runnable的子类对象? 因为要明确run方法所属对象
  
 两种线程创建方式的区别
具体区别见备注
第一种和第二种比到底有什么好处呢?
第一种方式的话都继承子类乊后会造成资源丌共享
第二种的话，就徆方便了，实现一个接口，让多个线程去运行即可。这 样就可以实现资源的共享了
  
     Part 03 线程安全问题
 
 线程安全问题
导致线程安全问题的原因: 多个线程访问出现延迟。 线程随机性。
简单说:多条操作数据的代码被多个线程分开执行造成的。 注意:线程安全问题在理想状态下，丌容易出现，但一旦出现对
软件的影响是非常大的。 例子:卖票


1，继承 Thread 类。 步骤:
1，定义类继承 Thread。
2，覆盖 Thread 类中的 run 方法，run 方法用于存储多线程要运行的代码。 3，创建 Thread 类的子类对象创建线程。
4，调用 Thread 类中的 start 方法开启线程，并执行子类中的 run 方法。
特点:
    1.当类去描述事物，事物中有属性和行为。 如果行为中有部分代码需要被多线程所执行，同时还在操作属性。 就需要该类继承 Thread 类，产生该类的对象作为线程对象。 可是这样做会导致每一个对象中都存储一份属性数据。 无法在多个线程中共享该数据。加上静态，虽然实现了共享但是生命周期过长。
    2.如果一个类明确了自己的父类，那么很遗憾，它就不可以在继承 Thread。 因为 java 不允许类的多继承。
2，实现 Runnable 接口: 步骤:
    1，定义类实现 Runnable 接口。
    2，覆盖接口中的 run 方法，将多线程要运行的代码定义在方法中。
    3，通过 Thread 类创建线程对象，并将实现了 Runnable 接口的子类对象
    作为实际参数传递给 Thread 类的构造函数。
    为什么非要被 Runnable 接口的子类对象传递给 Thread 类的构造函数呢? 是因为线程对象在建立时，必须要明确自己要运行的 run 方法，而这个 run 方法 定义在了 Runnable 接口的子类中，所以要将该 run 方法所属的对象传递给 Thread
    类的构造函数。
    让线程对象一建立，就知道运行哪个 run 方法。
    4，调用 Thread 类中的 start 方法，开启线程，并执行 Runanble 接口子类中的 run 方法。
特点: 
    1.描述事物的类中封装了属性和行为，如果有部分代码需要被多线程所执行。 同时还在操作属性。那么可以通过实现 Runnable 接口的方式。 因为该方式是定义一个 Runnable 接口的子类对象，可以被多个线程所操作 实现了数据的共享。
    2.实现了 Runnable 接口的好处，避免了单继承的局限性。 也就说，一个类如果已经有了自己的父类是不可以继承 Thread 类的。 但是该类中还有需要被多线程执行的代码。这时就可以通过在该类上功能扩展的形式。
实现一个 Runnable 接口。
    所以在创建线程时，建议使用第二种方式。
需求:
    有两个储户，到同一个银行存钱，每次存 100，存 3 次，两个储户是随机存入的。

  
  
  
  